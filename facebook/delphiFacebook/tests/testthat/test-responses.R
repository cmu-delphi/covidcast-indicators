library(testthat)
library(dplyr)

# These tests cover the backfill and archiving behavior described in the
# indicator README, which is quite involved.

context("Test response merging and archiving functions")

test_that("first response with a token is used", {
  input_data <- data.frame(
    StartDate = as.Date(c("2020-02-01", "2020-02-02", "2020-01-05", "2020-06-01")),
    token = c("A", "B", "C", "D"),
    stringsAsFactors = FALSE
  )

  archive <- list(
    input_data = data.frame(
      StartDate = as.Date(c("2020-09-01", "2020-01-01", "2020-01-05")),
      token = c("A", "B", "C"),
      stringsAsFactors = FALSE
    )
  )

  out <- merge_responses(input_data, archive)
  expected <- data.frame(
    StartDate = as.Date(c("2020-01-01", "2020-01-05", "2020-02-01", "2020-06-01")),
    token = c("B", "C", "A", "D"),
    stringsAsFactors = FALSE
  )

  # need to do this to avoid checking the row names
  expect_equal(out$StartDate, expected$StartDate)
  expect_equal(out$token, expected$token)

  # However, if a token was previously seen long before it was used in the
  # archive, we should not include it in the output. If it was previously seen
  # *after* it occurred in the new data, we should keep the new data.
  archive$seen_tokens <- data.frame(
    token = c("A", "B", "C"),
    start_dt = as.Date(c("2019-01-01", "2020-01-15", "2020-02-01")),
    stringsAsFactors = FALSE
  )

  # yes, there are StartDate and start_dt columns and we need both...
  input_data$start_dt <- input_data$StartDate
  archive$input_data$start_dt <- archive$input_data$StartDate

  out <- merge_responses(input_data, archive)
  expected <- data.frame(
    StartDate = as.Date(c("2020-01-01", "2020-01-05", "2020-06-01")),
    token = c("B", "C", "D"),
    stringsAsFactors = FALSE
  )

  expect_equal(!!out$StartDate, !!expected$StartDate)
  expect_equal(!!out$token, !!expected$token)
})

test_that("in case of duplicates, new input takes precedence", {
  # Suppose there is an error in an input file and it gets stored in the
  # archive. (Maybe load_responses() has a bug in its calculations that we later
  # fix.) We should be able to re-run the pipeline with the new input file or
  # new calculations and have the new values take precedence over the archived
  # values.

  input_data <- data.frame(
    StartDate = as.Date(c("2020-02-01", "2020-02-02", "2020-01-05", "2020-06-01")),
    token = c("A", "B", "C", "D"),
    some_value = 1:4,
    stringsAsFactors = FALSE
  )

  archive <- list(
    input_data = data.frame(
      StartDate = as.Date(c("2020-09-01", "2020-01-01", "2020-01-05", "2020-06-01")),
      token = c("A", "B", "C", "D"),
      some_value = 5:8,
      stringsAsFactors = FALSE
    )
  )

  out <- merge_responses(input_data, archive)

  expected <- data.frame(
    StartDate = as.Date(c("2020-01-01", "2020-01-05", "2020-02-01", "2020-06-01")),
    token = c("B", "C", "A", "D"),
    some_value = c(6, 3, 1, 4),
    stringsAsFactors = FALSE
  )

  expect_equal(!!out$StartDate, !!expected$StartDate)
  expect_equal(!!out$token, !!expected$token)
  expect_equal(!!out$some_value, !!expected$some_value)
})

test_that("filter_responses works correctly", {
  params <- list(end_date=as.Date("2021-02-01"))
    
  input <- tibble(
    token = c("", 1, 1, 2, 3, 4, 5, 6, 7),
    S1 = c(1, 1, 1, 1, 1, 1, 0, 1, 1),
    DistributionChannel = c("notpreview", "notpreview", "notpreview", "notpreview", NA, "notpreview", "notpreview", "preview", "notpreview"),
    StartDate = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-02-24"),
    date = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-02-24")
  )
  
  expected <- tibble(
    token = c("1", "2", "4"),
    S1 = c(1, 1, 1),
    DistributionChannel = c("notpreview", "notpreview", "notpreview"),
    StartDate = c("2021-01-01", "2021-01-01", "2021-01-01"),
    date = c("2021-01-01", "2021-01-01", "2021-01-01")
  )
  
  expect_equal(filter_responses(input, params), 
               expected)
})

test_that("filter_data_for_aggregation works correctly", {
  params <- list(start_date=as.Date("2021-01-05"), static_dir=test_path("static"))
  
  input <- tibble(
    zip5 = c("00000", "10001", "10001", "10001", "10001", "10001", "10001", "10001", "10001", "10001", "10001", "10001", "10001"),
    hh_number_sick = c(0, NA, 4, -5, 55, 5, 5, 5, 3, 3, 0, 30, 1),
    hh_number_total = c(1, 4, NA, 5, 5, -5, 100, 5, 5, 1, 1, 30, 1),
    day = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2020-01-01"),
    date = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2020-01-01"),
    wave = 12
  )
  
  expected <- tibble(
    zip5 = c("10001", "10001", "10001", "10001"),
    hh_number_sick = c(5, 3, 0, 30),
    hh_number_total = c(5, 5, 1, 30),
    day = c("2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01"),
    date = c("2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01"),
    wave = 12
  )

  expect_equal(filter_data_for_aggregation(input, params),
               expected)
})

test_that("filter_complete_responses works correctly", {
  params <- list(
    start_date=as.Date("2020-01-05"),
    end_date=as.Date("2021-01-05"),
    backfill_days = 0,
    static_dir=test_path("static"))

  input <- tibble(
    token = c("", 1, NA, 2, 3, 4, 5, 6, 7),
    wave = c("", 1, 1, 2, 3, 4, 5, 6, 7),
    geo_id = "US",
    zip5 = "10001",
    A3 = "10001",
    B2b = c("1", "2", "2", NA, "32", "8", "8,2", NA, "1"),
    C11 = c("1", "2", NA, "2", "32", "8", "8,2", NA, "1"),
    UserLanguage = "English",
    StartDatetime = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-02-24"),
    EndDatetime = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-02-24"),
    Date = c("2021-01-01", "2021-01-01", "2021-01-02", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-01-01", "2021-02-24"),
    raceethnicity = c(NA, "Hispanic", NA, "Hispanic", NA, "Hispanic", NA, "Hispanic", "NonHispanicAsian")
  )
  
  # No raceethnicity field
  expected <- input[c(1, 2, 4:7), ] %>% select(-c(zip5, raceethnicity))
  out <- filter_complete_responses(input %>% select(-raceethnicity), params)
  expect_equal(out, expected)
  
  # raceethnicity field included
  input$raceethnicity <- "Hispanic"
  expected <- input[c(1, 2, 4:7), ] %>% select(-c(zip5))
  out <- filter_complete_responses(input, params)
  expect_equal(out, expected)
})

test_that("V4 bodge works correctly", {
  foo <- tibble(
    UserLanguage = c("EN", "ES", "EN", NA, "ZH"),
    V4_1 = c(NA, 2, 3, 1, NA),
    V4a_1 = c(2, NA, NA, NA, 3),
    V4_2 = c(NA, 2, 3, 1, NA),
    V4a_2 = c(2, NA, NA, NA, 3),
    V4_3 = c(NA, 2, 3, 1, NA),
    V4a_3 = c(2, NA, NA, NA, 3),
    V4_4 = c(NA, 2, 3, 1, NA),
    V4a_4 = c(2, NA, NA, NA, 3),
    V4_5 = c(NA, 2, 3, 1, NA),
    V4a_5 = c(2, NA, NA, NA, 3)
  )

  expected <- tibble(
    UserLanguage = foo$UserLanguage,
    V4_1 = c(2, NA, 3, NA, 3),
    V4a_1 = foo$V4a_1,
    V4_2 = c(2, NA, 3, NA, 3),
    V4a_2 = foo$V4a_2,
    V4_3 = c(2, NA, 3, NA, 3),
    V4a_3 = foo$V4a_3,
    V4_4 = c(2, NA, 3, NA, 3),
    V4a_4 = foo$V4a_4,
    V4_5 = c(2, NA, 3, NA, 3),
    V4a_5 = foo$V4a_5
  )

  expect_equal(bodge_v4_translation(foo),
               expected)

  # Ensure the bodge works when all responses are in English to V4a; see PR #888
  foo <- tibble(
    UserLanguage = "EN",
    V4a_1 = c(2, NA, NA, NA, 3),
    V4a_2 = c(2, NA, NA, NA, 3),
    V4a_3 = c(2, NA, NA, NA, 3),
    V4a_4 = c(1, NA, NA, NA, 3),
    V4a_5 = c(2, NA, NA, NA, 3)
  )

  expected <- tibble(
    UserLanguage = foo$UserLanguage,
    V4a_1 = foo$V4a_1,
    V4a_2 = foo$V4a_2,
    V4a_3 = foo$V4a_3,
    V4a_4 = foo$V4a_4,
    V4a_5 = foo$V4a_5,
    V4_1 = c(2, NA, NA, NA, 3),
    V4_2 = c(2, NA, NA, NA, 3),
    V4_3 = c(2, NA, NA, NA, 3),
    V4_4 = c(1, NA, NA, NA, 3),
    V4_5 = c(2, NA, NA, NA, 3)
  )

  expect_equal(bodge_v4_translation(foo),
               expected)

  # Ensure the bodge works when *no* responses are in English, but they're to
  # V4a, which needs no censoring
  foo <- tibble(
    UserLanguage = "ES",
    V4a_1 = c(2, NA, NA, NA, 3),
    V4a_2 = c(2, NA, NA, NA, 3),
    V4a_3 = c(2, NA, NA, NA, 3),
    V4a_4 = c(1, NA, NA, NA, 3),
    V4a_5 = c(2, NA, NA, NA, 3)
  )

  expected <- tibble(
    UserLanguage = foo$UserLanguage,
    V4a_1 = foo$V4a_1,
    V4a_2 = foo$V4a_2,
    V4a_3 = foo$V4a_3,
    V4a_4 = foo$V4a_4,
    V4a_5 = foo$V4a_5,
    V4_1 = c(2, NA, NA, NA, 3),
    V4_2 = c(2, NA, NA, NA, 3),
    V4_3 = c(2, NA, NA, NA, 3),
    V4_4 = c(1, NA, NA, NA, 3),
    V4_5 = c(2, NA, NA, NA, 3)
  )

  expect_equal(bodge_v4_translation(foo),
               expected)

  # Ensure functioning on earlier waves before V4a happened
  foo <- tibble(
    UserLanguage = "EN",
    V4_1 = c(2, NA, NA, NA, 3),
    V4_2 = c(2, NA, 4, NA, 3),
    V4_3 = c(2, NA, NA, NA, 3),
    V4_4 = c(1, NA, NA, NA, 3),
    V4_5 = c(2, NA, NA, NA, 3)
  )

  expect_equal(bodge_v4_translation(foo), foo)
})


test_that("C6/8 bodge works correctly", {
  ## Not-Wave 10
  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    C8_2 = c(1, 2, 3, 4),
    C8_3 = c(1, 2, 3, 4)
  )

  expect_equal(bodge_C6_C8(input, wave = 1),
               input)

  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    C8_2 = c(1, 2, 3, 4),
    C8_3 = c(1, 2, 3, 4)
  )
  
  expect_equal(bodge_C6_C8(input, wave = 11),
               input)

  ## Wave 10
  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    C8_2 = c(1, 2, 3, 4),
    C8_3 = c(1, 2, 3, 4)
  )

  expected <- tibble(
    C6a = c(1, 2, 3, 4),
    C8a_1 = c(1, 2, 3, 4),
    C8a_2 = c(1, 2, 3, 4),
    C8a_3 = c(1, 2, 3, 4)
  )
  
  expect_equal(bodge_C6_C8(input, wave = 10),
               expected)
})

test_that("B13 bodge works correctly", {
  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4)
  )
  expect_equal(bodge_B13(input, wave = 1),
               input)
  
  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    "B13 " = c(1, 2, 3, 4)
  )
  
  expected <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    B13 = c(1, 2, 3, 4)
  )
  
  expect_equal(bodge_B13(input, wave = 11),
               expected)
  
  input <- tibble(
    C6 = c(1, 2, 3, 4),
    C8_1 = c(1, 2, 3, 4),
    B13 = c(1, 2, 3, 4)
  )
  expect_equal(bodge_B13(input, wave = 11),
               input)
})

test_that("E1 bodge works correctly", {
  input <- tibble(
    E1_1 = c(1, 2, 3, 1),
    E1_2 = c(1, 2, 3, 2),
    E1_3 = c(1, 2, 3, 3),
    E1_4 = c(1, 2, 3, 4)
  )
  expect_equal(bodge_E1(input, wave = NA), input)
  
  input_4_to_7 <- tibble(
    E1_4 = c(1, 2, 3, 1),
    E1_5 = c(1, 2, 3, 2),
    E1_6 = c(1, 2, 3, 3),
    E1_7 = c(1, 2, 3, 4)
  )

  expect_equal(bodge_E1(input_4_to_7, wave = NA), input)
  
  input_mixed <- tibble(
    E1_4 = c(1, 2, 3, 1),
    E1_2 = c(1, 2, 3, 2),
    E1_3 = c(1, 2, 3, 3),
    E1_7 = c(1, 2, 3, 4)
  )
  expect_equal(bodge_E1(input_mixed, wave = NA), input_mixed)
  
  input_both <- tibble(
    E1_1 = c(1, 2, 3, 1),
    E1_2 = c(1, 2, 3, 2),
    E1_3 = c(1, 2, 3, 3),
    E1_4 = c(1, 2, 3, 1),
    E1_5 = c(1, 2, 3, 2),
    E1_6 = c(1, 2, 3, 3),
    E1_7 = c(1, 2, 3, 4)
  )
  expect_error(bodge_E1(input_both, wave = NA),
               "fields E1_1-E1_4 should not be present at the same time as fields E1_4-E1_7"
  )
})

